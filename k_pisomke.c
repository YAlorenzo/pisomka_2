#include <stdio.h>

/*
    Подготовка к второй писомке по ALPR
    Klymenchuk Yevhenii - 21.11.2024

    задачи в файле будут нумерованы согласно списку тем ниже
    темы на которые будут задачи:
    1)теоретический вопрос о массивах (касающийся инициализации)
    2)часть програмы должны ответить что будет результатом выполнения (касающийся строк)
    3)изминить какие-то символы другими (в строке)
    4)считать числа с файла в массив
    5)обратная задача к четвертой надо записать массив в файл
    6)битовые операции (6 примеров)
    7)пример с двухразмерной матрицей (подобный есть в цвике)

*/


// ---- 1 ----
// инициализация массивов
int inizializate_array(){
     /*
      -- варианты инициализации массивов --
    */

    // инициализация массивов начальными значениями:
    int array_1[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // массив из 10 элементов
    int array_2[10] = {1, 2, 3}; // на свободных местах будут нули 1 2 3 0 0 0 0 0 0 0
    int array_3[10] = {0}; // инициализация всех значений массива нулями
    int array_4[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}; //  !!! ОШИБКА при инициализации записывать либо меньшее кол-во символов либо равное!
    int array_5[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; // размер массива будет равен количеству начальных значений
    int array_6[10] = {1, [2] = 3, 4, [9] = 5}; // инициализация с указанием индекса. результат: 1 0 3 4 0 0 0 0 0 5

     // Массив указателей на массивы
    int* arrays[] = {array_1, array_2, array_3, array_4, array_5, array_6}; // получаеться двумерный массив
    // Массив с названиями массивов
    char* array_names[] = {"array_1", "array_2", "array_3", "array_4", "array_5", "array_6"};
    /*
    вычисление количества элемнтов массива с помощью sizeof()
    sizeof() - возвращает число байт которое занимает переменая или тип данных в памяти
    size_t - целочисленый тип без знака - unsigned long long
    */

    size_t bytes_marks = sizeof(array_1); // здесь будет: 10 * 4 = 40 10-кол-во елементов массива 4-размер каждого елемента в памяти
    size_t size_marks =  sizeof(array_1) / sizeof(array_1[0]); // количество елемнтов в массиве: 40 / 4 = 10
    size_t size_marks_point =  sizeof(array_1) / sizeof(*array_1); // такой вариант записи идентичен первому. УКАЗАТЕЛЬ ВСЕГДА ССЫЛАЕТЬСЯ НА ПЕРВЫЙ ЕЛЕМЕНТ МАССИВА
    printf("bytes_marks = %zu\t size_marks = %zu\t size_marks = %zu\n", bytes_marks, size_marks, size_marks_point);  // %zu - спецификатор для вывода переменных типа size_t



     // цикл для вывода всех массивов
    for (int i = 0; i < 6; i++) {
        printf("%s:\n", array_names[i]);
        for (int j = 0; j < 10; j++) {
            printf("%d ", arrays[i][j]);
        }
        printf("\n");
    }
}

/*
   ЗАДАЧИ С ПРОШЛОГОДНИХ ПИСОМОК по инициализации массивов

   1) Укажите правильную инициализацию массива целых чисел с размером 5
     a) int a[] = {2, 3, 1, 3, 2};
     b) int n=5, a[n]; --- размер массива не может быть переменной. он должен быть константой
     c) a[5] int; --- тип должен идти в начале
     d) int a[5] = {1, 2, 3};


     Ответ: a и d



     2) Укажите правильную инициализацию массива десятичных чисел с размером 5
     a) float n = 5.0, a[n];
     b) a[5] float;
     c) float a[] = {1, 3.0, 1.0, 1, 3};
     d) float a[5] = {1.0, 2.0, 3};

     Ответ: c и d
*/
//-----------------------------------------------------------------------------------------------------------------

// ---- 2 ----
// ЗАДАЧИ С ПРОШЛОГОДНИХ ПИСОМОК по "что будет результатом работы" (строки)

//1)
int func_str_1() {
    char s[] = "ABCDEFG";
    for (int i=0; i<7; i++){
        if(s[i] == 'C') s[i] = '*';
        else s[i]++;
    }
    printf("%s", s);
}
/*
   варианты ответа:
   a)BCD*FGH
   b)AB*DEFG
   c)BCD*
   d)BC*EFGH

   Ответ: d) так как мы всегда увеличиваем код ASCII на один.
*/
//-----------------------------------------------------------------------------------------------------------------

// ---- 3 ----
// ЗАДАЧИ С ПРОШЛОГОДНИХ ПИСОМОК по "написать функцию" (строки)
/*
   1)Напишите функцию которая в строке изменит все маленькие буквы на * и вернет количество измененных знаков изменных знаков
   !!! использовать strlen() запрещенно
*/
// мое решение
int male_pismena(char *str){
    int i = 0;
    int pocet_znakov = 0;

    // вычисляем длинну строки
    while (str[i] != '\0'){
        if(str[i] >= 'a' && str[i] <= 'z'){
            str[i] = '*';
            pocet_znakov++;
        }
        i++;
    }
    printf("%s\n", str);
    printf("pocet_znakov: %d\n", pocet_znakov);

    return pocet_znakov;

}

// ---- 4 ----
// ЗАДАЧИ С ПРОШЛОГОДНИХ ПИСОМОК по "написать функцию" (считать числа с файла в массив)
/*
   1)Напишите функцию которая считает ЦЕЛЫЕ числа из файла и запишет их в массив целых чисел
   в массив попадут только отрицательные числа которые парные и вернет количество записаных чисел.
*/
// мое решение ---
int kladne_parne(int pole[], FILE *fr){
    int num = 0;
    int i = 0;
    while(fscanf(fr, "%d", &num) != EOF){
        if(num > 0 && !(num % 2)){
            pole[i] = num;
            i++;
        }
    }

    for (int j = 0; j < i; j++){
        printf("%d ", pole[j]);
    }
    printf("\n pocet_cisel: %d", i);

    return i;
}

// ----------------------------
// ниже тоже работа с файлом и массивом только более сложная
// я добавил условия и реализовал алгоритм сортировки массива вынес все в отдельные функции чтобы было более читабельно



// сортировка чисел от меньшего к большему
void sort_numbers(int numbers[], int size){
    int buf = 0; // Временная переменная для обмена значений

    // Внешний цикл: количество проходов по массиву
    // После каждого прохода самый большой элемент оказывается в конце
    for (int pass = 0; pass < size - 1; pass++) {
        // Внутренний цикл: сравнение соседних элементов
        // На каждом проходе уменьшается количество проверяемых элементов
        for (int j = 0; j < size - pass - 1; j++) {
            // Если текущий элемент больше следующего, меняем их местами
            if (numbers[j] > numbers[j + 1]) {
                buf = numbers[j];          // Сохраняем значение numbers[j] во временную переменную
                numbers[j] = numbers[j + 1]; // Перемещаем numbers[j + 1] в numbers[j]
                numbers[j + 1] = buf;       // Перемещаем старое значение numbers[j] в numbers[j + 1]
            }
        }
    }

    // вывод чисел
    for (int j = 0; j < size; j++){
        printf("%d ", numbers[j]);
    }
}

// запись чисел наоборт
void revers_numbers(const char *str, int numbers[], int size){
    puts(str);

    for(int j = size - 1; j >= 0; j--){
        printf("%d ", numbers[j]);
    }
    printf("\n");
}


int file_to_array(){
     int all_numbers[100]; // Массив всех чисел
     int even_numbers[100]; // Массив четных чисел
     int odd_numbers[100]; // Массив нечетных чисел
     int a_i = 0, e_i = 0, o_i = 0; // итераторы массивов

     FILE *fr = fopen("cisla.txt", "r"); // инициализация файла

     // проверка на наличие файла
     if(fr == NULL){
        printf("Error, file open!\n");
        return 1;
     }

     // считывание чисел с файла и запись в массив соответсвенно условию
     while(fscanf(fr, "%d", &all_numbers[a_i]) != EOF){
         // проврка на четность
         if(!(all_numbers[a_i] % 2)){
            even_numbers[e_i] = all_numbers[a_i];
            e_i++;
         }
         // нечетные числа
         else {
            odd_numbers[o_i] = all_numbers[a_i];
            o_i++;
         }

         a_i++;
     }
     fclose(fr); // Закрытие файла


     // выводим числа в обратном порядке
     revers_numbers("revers even numbers", even_numbers, e_i); // вывод четных чисел в обратном порядке
     revers_numbers("revers odd numbers", odd_numbers, o_i); // вывод нечетных чисел в обратном порядке


     printf("Sorted numbers in ascending order: ");
     sort_numbers(all_numbers, a_i);


     printf("\n");
}

int main() {
    // для первого
    // inizializate_array();


    // для теста 3 примера
    /*
    char str[] = "AbRaKaDaBrA!";
    male_pismena(str);
    */


    // это для теста 4 примера
    /*
    int pole[100];
    FILE *fr = fopen("cisla.txt", "r");

    if (fr == NULL) {
        printf("Error opening file!\n");
        return 1;
    }
    kladne_parne(pole, fr);
    fclose(fr);
    */

    // дополнительно ---
    // file_to_array();

}

